(this["webpackJsonpstreamlit-browser"]=this["webpackJsonpstreamlit-browser"]||[]).push([[35],{1605:function(t,e,n){(function(e){var n,a,s,i,o,r,l,_,h,c=function(t,e){return Array.isArray(t)&&Array.isArray(e)?t.concat(e):t+e},f=function(t,e){if(null==e);else{if(Array.isArray(e)){for(var n=0;n<e.length;n++)if(d(t,e[n]))return!0;return!1}if(e.constructor===Object){for(var a in e)if(t==a)return!0;return!1}if(e.constructor==String)return e.indexOf(t)>=0}var s=Error("Not a container: "+e);throw s.name="TypeError",s},d=function t(e,n){if(null==e||null==n);else{if(Array.isArray(e)&&Array.isArray(n)){for(var a=0,s=e.length==n.length;s&&a<e.length;)s=t(e[a],n[a]),a+=1;return s}if(e.constructor===Object&&n.constructor===Object){var i=Object.keys(e),o=Object.keys(n);i.sort(),o.sort();var r;for(a=0,s=t(i,o);s&&a<i.length;)s=t(e[r=i[a]],n[r]),a+=1;return s}}return e==n},u=function(t,n){if("undefined"===typeof t||"undefined"!==typeof window&&window===t||"undefined"!==typeof e&&e===t)throw"Class constructor is called as a function.";for(var a in t)void 0!==Object[a]||"function"!==typeof t[a]||t[a].nobind||(t[a]=t[a].bind(t));t.__init__&&t.__init__.apply(t,n)},g=function(t,e){if(("number"===typeof t)+("number"===typeof e)===1){if(t.constructor===String)return w.call(t,e);if(e.constructor===String)return w.call(e,t);if(Array.isArray(e)){var n=t;t=e,e=n}if(Array.isArray(t)){for(var a=[],s=0;s<e;s++)a=a.concat(t);return a}}return t*e},p=function(t){return null===t||"object"!==typeof t?t:void 0!==t.length?!!t.length&&t:void 0!==t.byteLength?!!t.byteLength&&t:t.constructor!==Object||!!Object.getOwnPropertyNames(t).length&&t},v=function(t){if(!Array.isArray(this))return this.append.apply(this,arguments);this.push(t)},m=function(t,e){return this.constructor!==Object?this.get.apply(this,arguments):void 0!==this[t]?this[t]:void 0!==e?e:null},x=function(){return"function"===typeof this.keys?this.keys.apply(this,arguments):Object.keys(this)},y=function(t){if(this.constructor!==String)return this.lstrip.apply(this,arguments);t=void 0===t?" \t\r\n":t;for(var e=0;e<this.length;e++)if(t.indexOf(this[e])<0)return this.slice(e);return""},b=function(t){if(!Array.isArray(this))return this.remove.apply(this,arguments);for(var e=0;e<this.length;e++)if(d(this[e],t))return void this.splice(e,1);var n=Error(t);throw n.name="ValueError",n},w=function(t){if(this.repeat)return this.repeat(t);if(t<1)return"";for(var e="",n=this.valueOf();t>1;)1&t&&(e+=n),t>>=1,n+=n;return e+n},P=function(t){return this.constructor!==String?this.startswith.apply(this,arguments):0==this.indexOf(t)};h=window.console,_=function(t,e){var n,a,s,i,o,r,l;for(e=void 0===e?"periodic check":e,i=[];a=t.getError(),!(d(a,t.NO_ERROR)||p(i)&&d(a,i[i.length-1]));)v.call(i,a);if(i.length){for(o="","object"!==typeof(r=i)||Array.isArray(r)||(r=Object.keys(r)),l=0;l<r.length;l+=1)n=r[l],o=c(o,n);throw(s=new Error("RuntimeError:OpenGL got errors ("+e+"): "+o)).name="RuntimeError",s}return null},(a=function(){u(this,arguments)}).prototype._base_class=Object,a.prototype._class_name="GlooObject",a.prototype.__init__=function(t){if(this._gl=t,this.handle=null,this._create(),null===this.handle)throw"AssertionError: this.handle !== null";return null},a.prototype._create=function(){var t;throw(t=new Error("NotImplementedError:")).name="NotImplementedError",t},((i=function(){u(this,arguments)}).prototype=Object.create(a.prototype))._base_class=a.prototype,i.prototype._class_name="Program",i.prototype.UTYPEMAP={float:"uniform1fv",vec2:"uniform2fv",vec3:"uniform3fv",vec4:"uniform4fv",int:"uniform1iv",ivec2:"uniform2iv",ivec3:"uniform3iv",ivec4:"uniform4iv",bool:"uniform1iv",bvec2:"uniform2iv",bvec3:"uniform3iv",bvec4:"uniform4iv",mat2:"uniformMatrix2fv",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv",sampler1D:"uniform1i",sampler2D:"uniform1i",sampler3D:"uniform1i"},i.prototype.ATYPEMAP={float:"vertexAttrib1f",vec2:"vertexAttrib2f",vec3:"vertexAttrib3f",vec4:"vertexAttrib4f"},i.prototype.ATYPEINFO={float:[1,5126],vec2:[2,5126],vec3:[3,5126],vec4:[4,5126]},i.prototype._create=function(){return this.handle=this._gl.createProgram(),this.locations={},this._unset_variables=[],this._validated=!1,this._samplers={},this._attributes={},this._known_invalid=[],null},i.prototype.delete=function(){return this._gl.deleteProgram(this.handle),null},i.prototype.activate=function(){return this._gl.useProgram(this.handle),null},i.prototype.deactivate=function(){return this._gl.useProgram(0),null},i.prototype.set_shaders=function(t,e){var n,a,s,i,o,r,l,_,h,f,d,u,g;for(r=this._gl,this._linked=!1,d=[[t,g=r.createShader(r.VERTEX_SHADER),"vertex"],[e,o=r.createShader(r.FRAGMENT_SHADER),"fragment"]],_=0;_<2;_+=1)if(n=(f=d[_])[0],l=f[1],u=f[2],r.shaderSource(l,n),r.compileShader(l),h=r.getShaderParameter(l,r.COMPILE_STATUS),!p(h))throw i=r.getShaderInfoLog(l),(s=new Error("RuntimeError:"+c("errors in "+u+" shader:\n",i))).name="RuntimeError",s;if(r.attachShader(this.handle,g),r.attachShader(this.handle,o),r.linkProgram(this.handle),!p(r.getProgramParameter(this.handle,r.LINK_STATUS)))throw(a=new Error("RuntimeError:Program link error:\n"+r.getProgramInfoLog(this.handle))).name="RuntimeError",a;return this._unset_variables=this._get_active_attributes_and_uniforms(),r.detachShader(this.handle,g),r.detachShader(this.handle,o),r.deleteShader(g),r.deleteShader(o),this._known_invalid=[],this._linked=!0,null},i.prototype._get_active_attributes_and_uniforms=function(){var t,e,n,a,s,i,o,r,l,_,h,f,d,u,g,m,x,y;for(r=this._gl,this.locations={},u=new window.RegExp("(\\w+)\\s*(\\[(\\d+)\\])\\s*"),s=r.getProgramParameter(this.handle,r.ACTIVE_UNIFORMS),e=r.getProgramParameter(this.handle,r.ACTIVE_ATTRIBUTES),y=[],"object"!==typeof(m=[[t=[],e,r.getActiveAttrib,r.getAttribLocation],[y,s,r.getActiveUniform,r.getUniformLocation]])||Array.isArray(m)||(m=Object.keys(m)),x=0;x<m.length;x+=1)for(n=(g=m[x])[0],a=g[1],i=g[2],o=g[3],l=0;l<a;l+=1){if(f=(d=(_=i.call(r,this.handle,l)).name).match(u),p(f))for(d=f[1],h=0;h<_.size;h+=1)v.call(n,[d+"["+h+"]",_.type]);else v.call(n,[d,_.type]);this.locations[d]=o.call(r,this.handle,d)}return c(function(){var e,n,a,s=[];for("object"!==typeof(n=t)||Array.isArray(n)||(n=Object.keys(n)),a=0;a<n.length;a++)e=n[a],s.push(e[0]);return s}.apply(this),function(){var t,e,n,a=[];for("object"!==typeof(e=y)||Array.isArray(e)||(e=Object.keys(e)),n=0;n<e.length;n++)t=e[n],a.push(t[0]);return a}.apply(this))},i.prototype.set_texture=function(t,e){var n,a,s;if(!p(this._linked))throw(n=new Error("RuntimeError:Cannot set uniform when program has no code")).name="RuntimeError",n;return a=m.call(this.locations,t,-1),p(a<0)?(f(t,this._known_invalid)||(v.call(this._known_invalid,t),h.log("Variable "+t+" is not an active texture")),null):(f(t,this._unset_variables)&&b.call(this._unset_variables,t),this.activate(),s=x.call(this._samplers).length,f(t,this._samplers)&&(s=this._samplers[t][this._samplers[t].length-1]),this._samplers[t]=[e._target,e.handle,s],this._gl.uniform1i(a,s),null)},i.prototype.set_uniform=function(t,e,n){var a,s,i,o,r,l,_;if(!p(this._linked))throw(i=new Error("RuntimeError:Cannot set uniform when program has no code")).name="RuntimeError",i;if(r=m.call(this.locations,t,-1),p(r<0))return f(t,this._known_invalid)||(v.call(this._known_invalid,t),h.log("Variable "+t+" is not an active uniform")),null;if(f(t,this._unset_variables)&&b.call(this._unset_variables,t),s=1,P.call(e,"mat")||(a=m.call({int:"float",bool:"float"},e,y.call(e,"ib")),s=Math.floor(n.length/this.ATYPEINFO[a][0])),p(s>1))for(l=0;l<s;l+=1)f(t+"["+l+"]",this._unset_variables)&&f(_=t+"["+l+"]",this._unset_variables)&&b.call(this._unset_variables,_);return o=this.UTYPEMAP[e],this.activate(),P.call(e,"mat")?this._gl[o](r,!1,n):this._gl[o](r,n),null},i.prototype.set_attribute=function(t,e,n,a,s){var i,o,r,_,c,d;if(a=void 0===a?0:a,s=void 0===s?0:s,!p(this._linked))throw(o=new Error("RuntimeError:Cannot set attribute when program has no code")).name="RuntimeError",o;return c=n instanceof l,_=m.call(this.locations,t,-1),p(_<0)?(f(t,this._known_invalid)||(v.call(this._known_invalid,t),p(c)&&p(s>0)||h.log("Variable "+t+" is not an active attribute")),null):(f(t,this._unset_variables)&&b.call(this._unset_variables,t),this.activate(),p(c)?(r="vertexAttribPointer",i=[(d=this.ATYPEINFO[e])[0],d[1],this._gl.FALSE,a,s],this._attributes[t]=[n.handle,_,r,i]):(r=this.ATYPEMAP[e],this._attributes[t]=[0,_,r,n]),null)},i.prototype._pre_draw=function(){var t,e,n,a,s,i,o,r,l,_,h,f;for(f in this.activate(),o=this._samplers)o.hasOwnProperty(f)&&(l=(i=f=o[f])[0],r=i[1],_=i[2],this._gl.activeTexture(c(this._gl.TEXTURE0,_)),this._gl.bindTexture(l,r));for(f in s=this._attributes)s.hasOwnProperty(f)&&(h=(a=f=s[f])[0],e=a[1],n=a[2],t=a[3],p(h)?(this._gl.bindBuffer(this._gl.ARRAY_BUFFER,h),this._gl.enableVertexAttribArray(e),this._gl[n].apply(this._gl,[].concat([e],t))):(this._gl.bindBuffer(this._gl.ARRAY_BUFFER,null),this._gl.disableVertexAttribArray(e),this._gl[n].apply(this._gl,[].concat([e],t))));return p(this._validated)||(this._validated=!0,this._validate()),null},i.prototype._validate=function(){var t;if(this._unset_variables.length&&h.log("Program has unset variables: "+this._unset_variables),this._gl.validateProgram(this.handle),!p(this._gl.getProgramParameter(this.handle,this._gl.VALIDATE_STATUS)))throw h.log(this._gl.getProgramInfoLog(this.handle)),(t=new Error("RuntimeError:Program validation error")).name="RuntimeError",t;return null},i.prototype.draw=function(t,e){var n,a,i,o,r;if(!p(this._linked))throw(a=new Error("RuntimeError:Cannot draw program if code has not been set")).name="RuntimeError",a;return _(this._gl,"before draw"),p(e instanceof s)?(this._pre_draw(),e.activate(),n=e._buffer_size/2,o=this._gl.UNSIGNED_SHORT,this._gl.drawElements(t,n,o,0),e.deactivate()):(i=(r=e)[0],n=r[1],p(n)&&(this._pre_draw(),this._gl.drawArrays(t,i,n))),_(this._gl,"after draw"),null},((n=function(){u(this,arguments)}).prototype=Object.create(a.prototype))._base_class=a.prototype,n.prototype._class_name="Buffer",n.prototype._target=null,n.prototype._usage=35048,n.prototype._create=function(){return this.handle=this._gl.createBuffer(),this._buffer_size=0,null},n.prototype.delete=function(){return this._gl.deleteBuffer(this.handle),null},n.prototype.activate=function(){return this._gl.bindBuffer(this._target,this.handle),null},n.prototype.deactivate=function(){return this._gl.bindBuffer(this._target,null),null},n.prototype.set_size=function(t){return d(t,this._buffer_size)||(this.activate(),this._gl.bufferData(this._target,t,this._usage),this._buffer_size=t),null},n.prototype.set_data=function(t,e){return this.activate(),this._gl.bufferSubData(this._target,t,e),null},(l=function(){u(this,arguments)}).prototype=Object.create(n.prototype),l.prototype._base_class=n.prototype,l.prototype._class_name="VertexBuffer",l.prototype._target=34962,(s=function(){u(this,arguments)}).prototype=Object.create(n.prototype),s.prototype._base_class=n.prototype,s.prototype._class_name="IndexBuffer",s.prototype._target=34963,((o=function(){u(this,arguments)}).prototype=Object.create(a.prototype))._base_class=a.prototype,o.prototype._class_name="Texture2D",o.prototype._target=3553,o.prototype._types={Int8Array:5120,Uint8Array:5121,Int16Array:5122,Uint16Array:5123,Int32Array:5124,Uint32Array:5125,Float32Array:5126},o.prototype._create=function(){return this.handle=this._gl.createTexture(),this._shape_format=null,null},o.prototype.delete=function(){return this._gl.deleteTexture(this.handle),null},o.prototype.activate=function(){return this._gl.bindTexture(this._target,this.handle),null},o.prototype.deactivate=function(){return this._gl.bindTexture(this._target,0),null},o.prototype._get_alignment=function(t){var e,n,a;for("object"!==typeof(n=[4,8,2,1])||Array.isArray(n)||(n=Object.keys(n)),a=0;a<n.length;a+=1)if(e=n[a],d(t%e,0))return e;return null},o.prototype.set_wrapping=function(t,e){return this.activate(),this._gl.texParameterf(this._target,this._gl.TEXTURE_WRAP_S,t),this._gl.texParameterf(this._target,this._gl.TEXTURE_WRAP_T,e),null},o.prototype.set_interpolation=function(t,e){return this.activate(),this._gl.texParameterf(this._target,this._gl.TEXTURE_MIN_FILTER,t),this._gl.texParameterf(this._target,this._gl.TEXTURE_MAG_FILTER,e),null},o.prototype.set_size=function(t,e){var n,a,s;return n=(a=t)[0],s=a[1],d([n,s,e],this._shape_format)||(this._shape_format=[n,s,e],this.activate(),this._gl.texImage2D(this._target,0,e,s,n,0,e,this._gl.UNSIGNED_BYTE,null)),this.u_shape=[n,s],null},o.prototype.set_data=function(t,e,n){var a,s,i,o,r,l,_,h,c,f;if(d(e.length,2)&&(e=[e[0],e[1],1]),this.activate(),i=this._shape_format[2],r=(l=e)[0],h=l[1],l[2],f=(_=t)[0],c=_[1],null===(o=m.call(this._types,n.constructor.name,null)))throw(s=new Error("ValueError:Type "+n.constructor.name+" not allowed for texture")).name="ValueError",s;return a=this._get_alignment(g(e[e.length-2],e[e.length-1])),d(a,4)||this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,a),this._gl.texSubImage2D(this._target,0,c,f,h,r,i,o,n),d(a,4)||this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,4),null},((r=function(){u(this,arguments)}).prototype=Object.create(o.prototype))._base_class=o.prototype,r.prototype._class_name="Texture3DLike",r.prototype.GLSL_SAMPLE_NEAREST="\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\n            shape.xyz = shape.zyx;  // silly row-major convention\n            float nrows = tiles.y, ncols = tiles.x;\n            // Don't let adjacent frames be interpolated into this one\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\n\n            float zindex = floor(texcoord.z * shape.z);\n\n            // Do a lookup in the 2D texture\n            float u = (mod(zindex, ncols) + texcoord.x) / ncols;\n            float v = (floor(zindex / ncols) + texcoord.y) / nrows;\n\n            return texture2D(tex, vec2(u,v));\n        }\n    ",r.prototype.GLSL_SAMPLE_LINEAR="\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\n            shape.xyz = shape.zyx;  // silly row-major convention\n            float nrows = tiles.y, ncols = tiles.x;\n            // Don't let adjacent frames be interpolated into this one\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\n\n            float z = texcoord.z * shape.z;\n            float zindex1 = floor(z);\n            float u1 = (mod(zindex1, ncols) + texcoord.x) / ncols;\n            float v1 = (floor(zindex1 / ncols) + texcoord.y) / nrows;\n\n            float zindex2 = zindex1 + 1.0;\n            float u2 = (mod(zindex2, ncols) + texcoord.x) / ncols;\n            float v2 = (floor(zindex2 / ncols) + texcoord.y) / nrows;\n\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\n\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\n        }\n    ",r.prototype._get_tile_info=function(t){var e,n,a,s;if(n=this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),s=Math.floor(n/t[1]),s=Math.min(s,t[0]),a=window.Math.ceil(t[0]/s),p(g(a,t[2])>n))throw(e=new Error("RuntimeError:Cannot fit 3D data with shape "+t+" onto simulated 2D texture.")).name="RuntimeError",e;return[s,a]},r.prototype.set_size=function(t,e){var n,a,s,i;return a=(i=this._get_tile_info(t))[0],n=i[1],s=[g(t[1],a),g(t[2],n)],r.prototype._base_class.set_size.call(this,s,e),this.u_shape=[t[0],t[1],t[2]],this.u_tiles=[n,a],null},r.prototype.set_data=function(t,e,n){var a,s,i,o,l,_,h,c,f,u,v,m;if(d(e.length,3)&&(e=[e[0],e[1],e[2],1]),!function(t){for(var e=0;e<t.length;e++)if(!p(t[e]))return!1;return!0}(function(){var e,n,a,s=[];for("object"!==typeof(n=t)||Array.isArray(n)||(n=Object.keys(n)),a=0;a<n.length;a++)e=n[a],s.push(d(e,0));return s}.apply(this)))throw(i=new Error("ValueError:Texture3DLike does not support nonzero offset (for now)")).name="ValueError",i;if(l=(c=this._get_tile_info(e))[0],o=c[1],h=[g(e[1],l),g(e[2],o),e[3]],d(o,1))r.prototype._base_class.set_data.call(this,[0,0],h,n);else for(m=new(0,n.constructor)(g(g(h[0],h[1]),h[2])),r.prototype._base_class.set_data.call(this,[0,0],h,m),v=0;v<e[0];v+=1)_=(f=[Math.floor(v/o),v%o])[0],a=f[1],s=Math.floor(n.length/e[0]),u=n.slice(g(v,s),g(v+1,s)),r.prototype._base_class.set_data.call(this,[g(_,e[1]),g(a,e[2])],e.slice(1),u);return null},t.exports={Buffer:n,GlooObject:a,IndexBuffer:s,Program:i,Texture2D:o,Texture3DLike:r,VertexBuffer:l,check_error:_,console:h}}).call(this,n(29))},2344:function(t,e,n){"use strict";n.r(e);var a=n(204),s=n(65),i=n(1605),o=n(1081),r=n(1012);class l{constructor(t,e){this.gl=t,this.glyph=e,this.nvertices=0,this.size_changed=!1,this.data_changed=!1,this.visuals_changed=!1,this.init()}set_data_changed(t){t!=this.nvertices&&(this.nvertices=t,this.size_changed=!0),this.data_changed=!0}set_visuals_changed(){this.visuals_changed=!0}render(t,e,n){let a=1,i=1,o=this.glyph.renderer.map_to_screen([0*a,1*a,2*a],[0*i,1*i,2*i]),l=Object(s.a)(o,2),_=l[0],h=l[1];if(isNaN(_[0]+_[1]+_[2]+h[0]+h[1]+h[2]))return r.a.warn("WebGL backend (".concat(this.glyph.model.type,"): falling back to canvas rendering")),!1;a=100/Math.min(Math.max(Math.abs(_[1]-_[0]),1e-12),1e12),i=100/Math.min(Math.max(Math.abs(h[1]-h[0]),1e-12),1e12);var c=this.glyph.renderer.map_to_screen([0*a,1*a,2*a],[0*i,1*i,2*i]),f=Object(s.a)(c,2);if(_=f[0],h=f[1],Math.abs(_[1]-_[0]-(_[2]-_[1]))>1e-6||Math.abs(h[1]-h[0]-(h[2]-h[1]))>1e-6)return r.a.warn("WebGL backend (".concat(this.glyph.model.type,"): falling back to canvas rendering")),!1;const d=(_[1]-_[0])/a,u=(h[1]-h[0])/i,g=this.glyph.renderer.plot_view.canvas_view.webgl.canvas,p=g.width,v=g.height,m={pixel_ratio:this.glyph.renderer.plot_view.canvas.pixel_ratio,width:p,height:v,dx:_[0]/d,dy:h[0]/u,sx:d,sy:u};return this.draw(e,n,m),!0}}function _(t,e){return void 0!==t[e].spec.value}function h(t,e,n,a,s,i){let r;const l=i+"_color",h=i+"_alpha";if(s.doit)if(_(s,l)&&_(s,h))e.used=!1,r=Object(o.b)(s[l].value(),s[h].value()),t.set_attribute(n,"vec4",r);else{let i,c;e.used=!0,c=_(s,l)?(()=>{const t=[];for(let e=0,n=a;e<n;e++)t.push(s[l].value());return t})():s.cache[l+"_array"],i=_(s,h)?function(t,e){const n=new Float32Array(t);for(let a=0,s=t;a<s;a++)n[a]=e;return n}(a,s[h].value()):s.cache[h+"_array"];const f=new Float32Array(4*a);for(let t=0,e=a;t<e;t++){r=Object(o.b)(c[t],i[t]);for(let e=0,n=4;e<n;e++)f[4*t+e]=r[e]}e.set_size(4*a*4),e.set_data(0,f),t.set_attribute(n,"vec4",e)}else e.used=!1,t.set_attribute(n,"vec4",[0,0,0,0])}l.__name__="BaseGLGlyph";class c{constructor(t){this._atlas={},this._index=0,this._width=256,this._height=256,this.tex=new i.Texture2D(t),this.tex.set_wrapping(t.REPEAT,t.REPEAT),this.tex.set_interpolation(t.NEAREST,t.NEAREST),this.tex.set_size([this._height,this._width],t.RGBA),this.tex.set_data([0,0],[this._height,this._width],new Uint8Array(this._height*this._width*4)),this.get_atlas_data([1])}get_atlas_data(t){const e=t.join("-");if(void 0===this._atlas[e]){const n=this.make_pattern(t),a=Object(s.a)(n,2),i=a[0],o=a[1];this.tex.set_data([this._index,0],[1,this._width],new Uint8Array(i.map(t=>t+10))),this._atlas[e]=[this._index/this._height,o],this._index+=1}return this._atlas[e]}make_pattern(t){t.length>1&&t.length%2&&(t=t.concat(t));let e=0;var n,s=Object(a.a)(t);try{for(s.s();!(n=s.n()).done;){e+=n.value}}catch(_){s.e(_)}finally{s.f()}const i=[];let o=0;for(let a=0,h=t.length+2;a<h;a+=2){const e=Math.max(1e-4,t[a%t.length]),n=Math.max(1e-4,t[(a+1)%t.length]);i.push(o,o+e),o+=e+n}const r=this._width,l=new Float32Array(4*r);for(let a=0,h=r;a<h;a++){let t,n,s;const o=e*a/(r-1);let _=0,h=1e16;for(let e=0,a=i.length;e<a;e++){const t=Math.abs(i[e]-o);t<h&&(_=e,h=t)}_%2===0?(s=o<=i[_]?1:0,n=i[_],t=i[_+1]):(s=o>i[_]?-1:0,n=i[_-1],t=i[_]),l[4*a+0]=i[_],l[4*a+1]=s,l[4*a+2]=n,l[4*a+3]=t}return[l,e]}}c.__name__="DashAtlas";const f={miter:0,round:1,bevel:2},d={"":0,none:0,".":0,round:1,")":1,"(":1,o:1,"triangle in":2,"<":2,"triangle out":3,">":3,square:4,"[":4,"]":4,"=":4,butt:5,"|":5};class u extends l{init(){const t=this.gl;this._scale_aspect=0;this.prog=new i.Program(t),this.prog.set_shaders("\nprecision mediump float;\n\nconst float PI = 3.14159265358979323846264;\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\n\nuniform float u_pixel_ratio;\nuniform vec2 u_canvas_size, u_offset;\nuniform vec2 u_scale_aspect;\nuniform float u_scale_length;\n\nuniform vec4 u_color;\nuniform float u_antialias;\nuniform float u_length;\nuniform float u_linewidth;\nuniform float u_dash_index;\nuniform float u_closed;\n\nattribute vec2 a_position;\nattribute vec4 a_tangents;\nattribute vec2 a_segment;\nattribute vec2 a_angles;\nattribute vec2 a_texcoord;\n\nvarying vec4  v_color;\nvarying vec2  v_segment;\nvarying vec2  v_angles;\nvarying vec2  v_texcoord;\nvarying vec2  v_miter;\nvarying float v_length;\nvarying float v_linewidth;\n\nfloat cross(in vec2 v1, in vec2 v2)\n{\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\n{\n    return cross(v2-v1,v1-v3) / length(v2-v1);\n}\n\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    result = vec2( c*v.x - s*v.y,\n                   s*v.x + c*v.y );\n}\n\nvoid main()\n{\n    bool closed = (u_closed > 0.0);\n\n    // Attributes and uniforms to varyings\n    v_color = u_color;\n    v_linewidth = u_linewidth;\n    v_segment = a_segment * u_scale_length;\n    v_length = u_length * u_scale_length;\n\n    // Scale to map to pixel coordinates. The original algorithm from the paper\n    // assumed isotropic scale. We obviously do not have this.\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\n\n    // Correct angles for aspect ratio\n    vec2 av;\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\n    v_angles.x = atan(av.y, av.x);\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\n    v_angles.y = atan(av.y, av.x);\n\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\n    // and a modified alpha\n    v_color.a = min(v_linewidth, v_color.a);\n    v_linewidth = max(v_linewidth, 1.0);\n\n    // If color is fully transparent we just will discard the fragment anyway\n    if( v_color.a <= 0.0 ) {\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n\n    // This is the actual half width of the line\n    float w = ceil(u_antialias+v_linewidth)/2.0;\n\n    vec2 position = (a_position + u_offset) * abs_scale;\n\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\n    float u = a_texcoord.x;\n    float v = a_texcoord.y;\n    vec2 o1 = vec2( +t1.y, -t1.x);\n    vec2 o2 = vec2( +t2.y, -t2.x);\n\n    // This is a join\n    // ----------------------------------------------------------------\n    if( t1 != t2 ) {\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\n        vec2 t  = normalize(t1+t2);\n        vec2 o  = vec2( + t.y, - t.x);\n\n        if ( u_dash_index > 0.0 )\n        {\n            // Broken angle\n            // ----------------------------------------------------------------\n            if( (abs(angle) > THETA) ) {\n                position += v * w * o / cos(angle/2.0);\n                float s = sign(angle);\n                if( angle < 0.0 ) {\n                    if( u == +1.0 ) {\n                        u = v_segment.y + v * w * tan(angle/2.0);\n                        if( v == 1.0 ) {\n                            position -= 2.0 * w * t1 / sin(angle);\n                            u -= 2.0 * w / sin(angle);\n                        }\n                    } else {\n                        u = v_segment.x - v * w * tan(angle/2.0);\n                        if( v == 1.0 ) {\n                            position += 2.0 * w * t2 / sin(angle);\n                            u += 2.0*w / sin(angle);\n                        }\n                    }\n                } else {\n                    if( u == +1.0 ) {\n                        u = v_segment.y + v * w * tan(angle/2.0);\n                        if( v == -1.0 ) {\n                            position += 2.0 * w * t1 / sin(angle);\n                            u += 2.0 * w / sin(angle);\n                        }\n                    } else {\n                        u = v_segment.x - v * w * tan(angle/2.0);\n                        if( v == -1.0 ) {\n                            position -= 2.0 * w * t2 / sin(angle);\n                            u -= 2.0*w / sin(angle);\n                        }\n                    }\n                }\n                // Continuous angle\n                // ------------------------------------------------------------\n            } else {\n                position += v * w * o / cos(angle/2.0);\n                if( u == +1.0 ) u = v_segment.y;\n                else            u = v_segment.x;\n            }\n        }\n\n        // Solid line\n        // --------------------------------------------------------------------\n        else\n        {\n            position.xy += v * w * o / cos(angle/2.0);\n            if( angle < 0.0 ) {\n                if( u == +1.0 ) {\n                    u = v_segment.y + v * w * tan(angle/2.0);\n                } else {\n                    u = v_segment.x - v * w * tan(angle/2.0);\n                }\n            } else {\n                if( u == +1.0 ) {\n                    u = v_segment.y + v * w * tan(angle/2.0);\n                } else {\n                    u = v_segment.x - v * w * tan(angle/2.0);\n                }\n            }\n        }\n\n    // This is a line start or end (t1 == t2)\n    // ------------------------------------------------------------------------\n    } else {\n        position += v * w * o1;\n        if( u == -1.0 ) {\n            u = v_segment.x - w;\n            position -= w * t1;\n        } else {\n            u = v_segment.y + w;\n            position += w * t2;\n        }\n    }\n\n    // Miter distance\n    // ------------------------------------------------------------------------\n    vec2 t;\n    vec2 curr = a_position * abs_scale;\n    if( a_texcoord.x < 0.0 ) {\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\n\n        rotate( t1, +v_angles.x/2.0, t);\n        v_miter.x = signed_distance(curr, curr+t, position);\n\n        rotate( t2, +v_angles.y/2.0, t);\n        v_miter.y = signed_distance(next, next+t, position);\n    } else {\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\n\n        rotate( t1, -v_angles.x/2.0,t);\n        v_miter.x = signed_distance(prev, prev+t, position);\n\n        rotate( t2, -v_angles.y/2.0,t);\n        v_miter.y = signed_distance(curr, curr+t, position);\n    }\n\n    if (!closed && v_segment.x <= 0.0) {\n        v_miter.x = 1e10;\n    }\n    if (!closed && v_segment.y >= v_length)\n    {\n        v_miter.y = 1e10;\n    }\n\n    v_texcoord = vec2( u, v*w );\n\n    // Calculate position in device coordinates. Note that we\n    // already scaled with abs scale above.\n    vec2 normpos = position * sign(u_scale_aspect);\n    normpos += 0.5;  // make up for Bokeh's offset\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\n    gl_Position.y *= -1.0;\n}\n","\nprecision mediump float;\n\nconst float PI = 3.14159265358979323846264;\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\n\nuniform sampler2D u_dash_atlas;\n\nuniform vec2 u_linecaps;\nuniform float u_miter_limit;\nuniform float u_linejoin;\nuniform float u_antialias;\nuniform float u_dash_phase;\nuniform float u_dash_period;\nuniform float u_dash_index;\nuniform vec2 u_dash_caps;\nuniform float u_closed;\n\nvarying vec4  v_color;\nvarying vec2  v_segment;\nvarying vec2  v_angles;\nvarying vec2  v_texcoord;\nvarying vec2  v_miter;\nvarying float v_length;\nvarying float v_linewidth;\n\n// Compute distance to cap ----------------------------------------------------\nfloat cap( int type, float dx, float dy, float t, float linewidth )\n{\n    float d = 0.0;\n    dx = abs(dx);\n    dy = abs(dy);\n    if      (type == 0)  discard;  // None\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\n    else if (type == 4)  d = max(dx,dy);  // Square\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\n    return d;\n}\n\n// Compute distance to join -------------------------------------------------\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\n           in float linewidth )\n{\n    // texcoord.x is distance from start\n    // texcoord.y is distance from centerline\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\n\n    float dx = texcoord.x;\n\n    // Round join\n    if( type == 1 ) {\n        if (dx < segment.x) {\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\n            //d = length( texcoord - vec2(segment.x,0.0));\n        } else if (dx > segment.y) {\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\n            //d = length( texcoord - vec2(segment.y,0.0));\n        }\n    }\n    // Bevel join\n    else if ( type == 2 ) {\n        if (dx < segment.x) {\n            vec2 x = texcoord - vec2(segment.x,0.0);\n            d = max(d, max(abs(x.x), abs(x.y)));\n\n        } else if (dx > segment.y) {\n            vec2 x = texcoord - vec2(segment.y,0.0);\n            d = max(d, max(abs(x.x), abs(x.y)));\n        }\n        /*  Original code for bevel which does not work for us\n        if( (dx < segment.x) ||  (dx > segment.y) )\n            d = max(d, min(abs(x.x),abs(x.y)));\n        */\n    }\n\n    return d;\n}\n\nvoid main()\n{\n    // If color is fully transparent we just discard the fragment\n    if( v_color.a <= 0.0 ) {\n        discard;\n    }\n\n    // Test if dash pattern is the solid one (0)\n    bool solid =  (u_dash_index == 0.0);\n\n    // Test if path is closed\n    bool closed = (u_closed > 0.0);\n\n    vec4 color = v_color;\n    float dx = v_texcoord.x;\n    float dy = v_texcoord.y;\n    float t = v_linewidth/2.0-u_antialias;\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\n    float d = 0.0;\n\n    vec2 linecaps = u_linecaps;\n    vec2 dash_caps = u_dash_caps;\n    float line_start = 0.0;\n    float line_stop = v_length;\n\n    // Apply miter limit; fragments too far into the miter are simply discarded\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\n          discard;\n    }\n\n    // Solid line --------------------------------------------------------------\n    if( solid ) {\n        d = abs(dy);\n        if( (!closed) && (dx < line_start) ) {\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\n        }\n        else if( (!closed) &&  (dx > line_stop) ) {\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\n        }\n        else {\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\n        }\n\n    // Dash line --------------------------------------------------------------\n    } else {\n        float segment_start = v_segment.x;\n        float segment_stop  = v_segment.y;\n        float segment_center= (segment_start+segment_stop)/2.0;\n        float freq          = u_dash_period*width;\n        float u = mod( dx + u_dash_phase*width, freq);\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n        float dash_center= tex.x * width;\n        float dash_type  = tex.y;\n        float _start = tex.z * width;\n        float _stop  = tex.a * width;\n        float dash_start = dx - u + _start;\n        float dash_stop  = dx - u + _stop;\n\n        // Compute extents of the first dash (the one relative to v_segment.x)\n        // Note: this could be computed in the vertex shader\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\n            float u = mod(segment_start + u_dash_phase*width, freq);\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n            dash_center= tex.x * width;\n            //dash_type  = tex.y;\n            float _start = tex.z * width;\n            float _stop  = tex.a * width;\n            dash_start = segment_start - u + _start;\n            dash_stop = segment_start - u + _stop;\n        }\n\n        // Compute extents of the last dash (the one relatives to v_segment.y)\n        // Note: This could be computed in the vertex shader\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\n            float u = mod(segment_stop + u_dash_phase*width, freq);\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\n            dash_center= tex.x * width;\n            //dash_type  = tex.y;\n            float _start = tex.z * width;\n            float _stop  = tex.a * width;\n            dash_start = segment_stop - u + _start;\n            dash_stop  = segment_stop - u + _stop;\n        }\n\n        // This test if the we are dealing with a discontinuous angle\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\n        //if( dx < line_start) discontinuous = false;\n        //if( dx > line_stop)  discontinuous = false;\n\n        float d_join = join( int(u_linejoin), abs(dy),\n                            v_segment, v_texcoord, v_miter, v_linewidth );\n\n        // When path is closed, we do not have room for linecaps, so we make room\n        // by shortening the total length\n        if (closed) {\n             line_start += v_linewidth/2.0;\n             line_stop  -= v_linewidth/2.0;\n        }\n\n        // We also need to take antialias area into account\n        //line_start += u_antialias;\n        //line_stop  -= u_antialias;\n\n        // Check is dash stop is before line start\n        if( dash_stop <= line_start ) {\n            discard;\n        }\n        // Check is dash start is beyond line stop\n        if( dash_start >= line_stop ) {\n            discard;\n        }\n\n        // Check if current dash start is beyond segment stop\n        if( discontinuous ) {\n            // Dash start is beyond segment, we discard\n            if( (dash_start > segment_stop) ) {\n                discard;\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\n            }\n\n            // Dash stop is before segment, we discard\n            if( (dash_stop < segment_start) ) {\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\n            }\n\n            // Special case for round caps (nicer with this)\n            if( dash_caps.x == 1.0 ) {\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\n                    discard;\n                }\n            }\n\n            // Special case for round caps  (nicer with this)\n            if( dash_caps.y == 1.0 ) {\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\n                    discard;\n                }\n            }\n\n            // Special case for triangle caps (in & out) and square\n            // We make sure the cap stop at crossing frontier\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\n                    float a = v_angles.x/2.0;\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\n                    if( x > 0.0 ) discard;\n                    // We transform the cap into square to avoid holes\n                    dash_caps.x = 4.0;\n                }\n            }\n\n            // Special case for triangle caps (in & out) and square\n            // We make sure the cap stop at crossing frontier\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\n                    float a = v_angles.y/2.0;\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\n                    if( x > 0.0 ) discard;\n                    // We transform the caps into square to avoid holes\n                    dash_caps.y = 4.0;\n                }\n            }\n        }\n\n        // Line cap at start\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\n        }\n        // Line cap at stop\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\n        }\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\n        else if( dash_type < -0.5 ) {\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\n            if( (dx > line_start) && (dx < line_stop) )\n                d = max(d,d_join);\n        }\n        // Dash cap right\n        else if( dash_type > 0.5 ) {\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\n            if( (dx > line_start) && (dx < line_stop) )\n                d = max(d,d_join);\n        }\n        // Dash body (plain)\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\n            d = abs(dy);\n        }\n\n        // Line join\n        if( (dx > line_start) && (dx < line_stop)) {\n            if( (dx <= segment_start) && (dash_start <= segment_start)\n                && (dash_stop >= segment_start) ) {\n                d = d_join;\n                // Antialias at outer border\n                float angle = PI/2.+v_angles.x;\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\n                d = max(f,d);\n            }\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\n                     && (dash_stop >= segment_stop) ) {\n                d = d_join;\n                // Antialias at outer border\n                float angle = PI/2.+v_angles.y;\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\n                d = max(f,d);\n            }\n            else if( dx < (segment_start - v_linewidth/2.)) {\n                discard;\n            }\n            else if( dx > (segment_stop + v_linewidth/2.)) {\n                discard;\n            }\n        }\n        else if( dx < (segment_start - v_linewidth/2.)) {\n            discard;\n        }\n        else if( dx > (segment_stop + v_linewidth/2.)) {\n            discard;\n        }\n    }\n\n    // Distance to border ------------------------------------------------------\n    d = d - t;\n    if( d < 0.0 ) {\n        gl_FragColor = color;\n    } else {\n        d /= u_antialias;\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\n    }\n}\n"),this.index_buffer=new i.IndexBuffer(t),this.vbo_position=new i.VertexBuffer(t),this.vbo_tangents=new i.VertexBuffer(t),this.vbo_segment=new i.VertexBuffer(t),this.vbo_angles=new i.VertexBuffer(t),this.vbo_texcoord=new i.VertexBuffer(t),this.dash_atlas=new c(t)}draw(t,e,n){const a=e.glglyph;if(a.data_changed){if(!isFinite(n.dx)||!isFinite(n.dy))return;a._baked_offset=[n.dx,n.dy],a._set_data(),a.data_changed=!1}this.visuals_changed&&(this._set_visuals(),this.visuals_changed=!1);let s=n.sx,i=n.sy;const o=Math.sqrt(s*s+i*i);s/=o,i/=o,Math.abs(this._scale_aspect-i/s)>Math.abs(.001*this._scale_aspect)&&(a._update_scale(s,i),this._scale_aspect=i/s),this.prog.set_attribute("a_position","vec2",a.vbo_position),this.prog.set_attribute("a_tangents","vec4",a.vbo_tangents),this.prog.set_attribute("a_segment","vec2",a.vbo_segment),this.prog.set_attribute("a_angles","vec2",a.vbo_angles),this.prog.set_attribute("a_texcoord","vec2",a.vbo_texcoord),this.prog.set_uniform("u_length","float",[a.cumsum]),this.prog.set_texture("u_dash_atlas",this.dash_atlas.tex);const r=a._baked_offset;if(this.prog.set_uniform("u_pixel_ratio","float",[n.pixel_ratio]),this.prog.set_uniform("u_canvas_size","vec2",[n.width,n.height]),this.prog.set_uniform("u_offset","vec2",[n.dx-r[0],n.dy-r[1]]),this.prog.set_uniform("u_scale_aspect","vec2",[s,i]),this.prog.set_uniform("u_scale_length","float",[o]),this.I_triangles=a.I_triangles,this.I_triangles.length<65535)this.index_buffer.set_size(2*this.I_triangles.length),this.index_buffer.set_data(0,new Uint16Array(this.I_triangles)),this.prog.draw(this.gl.TRIANGLES,this.index_buffer);else{t=Array.from(this.I_triangles);const e=this.I_triangles.length,n=64008,s=[];for(let t=0,a=Math.ceil(e/n);t<a;t++)s.push([]);for(let a=0,i=t.length;a<i;a++){const e=t[a]%n;s[Math.floor(t[a]/n)].push(e)}for(let t=0,i=s.length;t<i;t++){const e=new Uint16Array(s[t]),i=t*n*4;0!==e.length&&(this.prog.set_attribute("a_position","vec2",a.vbo_position,0,2*i),this.prog.set_attribute("a_tangents","vec4",a.vbo_tangents,0,4*i),this.prog.set_attribute("a_segment","vec2",a.vbo_segment,0,2*i),this.prog.set_attribute("a_angles","vec2",a.vbo_angles,0,2*i),this.prog.set_attribute("a_texcoord","vec2",a.vbo_texcoord,0,2*i),this.index_buffer.set_size(2*e.length),this.index_buffer.set_data(0,e),this.prog.draw(this.gl.TRIANGLES,this.index_buffer))}}}_set_data(){this._bake(),this.vbo_position.set_size(4*this.V_position.length),this.vbo_position.set_data(0,this.V_position),this.vbo_tangents.set_size(4*this.V_tangents.length),this.vbo_tangents.set_data(0,this.V_tangents),this.vbo_angles.set_size(4*this.V_angles.length),this.vbo_angles.set_data(0,this.V_angles),this.vbo_texcoord.set_size(4*this.V_texcoord.length),this.vbo_texcoord.set_data(0,this.V_texcoord)}_set_visuals(){const t=Object(o.b)(this.glyph.visuals.line.line_color.value(),this.glyph.visuals.line.line_alpha.value()),e=d[this.glyph.visuals.line.line_cap.value()],n=f[this.glyph.visuals.line.line_join.value()];this.prog.set_uniform("u_color","vec4",t),this.prog.set_uniform("u_linewidth","float",[this.glyph.visuals.line.line_width.value()]),this.prog.set_uniform("u_antialias","float",[.9]),this.prog.set_uniform("u_linecaps","vec2",[e,e]),this.prog.set_uniform("u_linejoin","float",[n]),this.prog.set_uniform("u_miter_limit","float",[10]);const a=this.glyph.visuals.line.line_dash.value();let i=0,r=1;if(a.length){var l=this.dash_atlas.get_atlas_data(a),_=Object(s.a)(l,2);i=_[0],r=_[1]}this.prog.set_uniform("u_dash_index","float",[i]),this.prog.set_uniform("u_dash_phase","float",[this.glyph.visuals.line.line_dash_offset.value()]),this.prog.set_uniform("u_dash_period","float",[r]),this.prog.set_uniform("u_dash_caps","vec2",[e,e]),this.prog.set_uniform("u_closed","float",[0])}_bake(){let t,e,n,a,s,i,o,r;const l=this.nvertices,_=new Float64Array(this.glyph._x),h=new Float64Array(this.glyph._y),c=o=new Float32Array(2*l),f=new Float32Array(2*l),d=r=new Float32Array(4*l);for(let v=0,m=l;v<m;v++)c[2*v+0]=_[v]+this._baked_offset[0],c[2*v+1]=h[v]+this._baked_offset[1];this.tangents=e=new Float32Array(2*l-2);for(let v=0,m=l-1;v<m;v++)e[2*v+0]=o[2*(v+1)+0]-o[2*v+0],e[2*v+1]=o[2*(v+1)+1]-o[2*v+1];for(let v=0,m=l-1;v<m;v++)d[4*(v+1)+0]=e[2*v+0],d[4*(v+1)+1]=e[2*v+1],d[4*v+2]=e[2*v+0],d[4*v+3]=e[2*v+1];d[0]=e[0],d[1]=e[1],d[4*(l-1)+2]=e[2*(l-2)+0],d[4*(l-1)+3]=e[2*(l-2)+1];const u=new Float32Array(l);for(let v=0,m=l;v<m;v++)u[v]=Math.atan2(r[4*v+0]*r[4*v+3]-r[4*v+1]*r[4*v+2],r[4*v+0]*r[4*v+2]+r[4*v+1]*r[4*v+3]);for(let v=0,m=l-1;v<m;v++)f[2*v+0]=u[v],f[2*v+1]=u[v+1];const g=4*l-4;this.V_position=a=new Float32Array(2*g),this.V_angles=n=new Float32Array(2*g),this.V_tangents=s=new Float32Array(4*g),this.V_texcoord=i=new Float32Array(2*g);for(let v=0,m=l;v<m;v++)for(let t=0;t<4;t++){for(let e=0;e<2;e++)a[2*(4*v+t-2)+e]=c[2*v+e],n[2*(4*v+t)+e]=f[2*v+e];for(let e=0;e<4;e++)s[4*(4*v+t-2)+e]=d[4*v+e]}for(let v=0,m=l;v<m;v++)i[2*(4*v+0)+0]=-1,i[2*(4*v+1)+0]=-1,i[2*(4*v+2)+0]=1,i[2*(4*v+3)+0]=1,i[2*(4*v+0)+1]=-1,i[2*(4*v+1)+1]=1,i[2*(4*v+2)+1]=-1,i[2*(4*v+3)+1]=1;const p=6*(l-1);this.I_triangles=t=new Uint32Array(p);for(let v=0,m=l;v<m;v++)t[6*v+0]=0+4*v,t[6*v+1]=1+4*v,t[6*v+2]=3+4*v,t[6*v+3]=2+4*v,t[6*v+4]=0+4*v,t[6*v+5]=3+4*v}_update_scale(t,e){let n;const a=this.nvertices,s=4*a-4,i=this.tangents,o=new Float32Array(a-1),r=new Float32Array(2*a);this.V_segment=n=new Float32Array(2*s);for(let _=0,h=a-1;_<h;_++)o[_]=Math.sqrt(Math.pow(i[2*_+0]*t,2)+Math.pow(i[2*_+1]*e,2));let l=0;for(let _=0,h=a-1;_<h;_++)l+=o[_],r[2*(_+1)+0]=l,r[2*_+1]=l;for(let _=0,h=a;_<h;_++)for(let t=0;t<4;t++)for(let e=0;e<2;e++)n[2*(4*_+t)+e]=r[2*_+e];this.cumsum=l,this.vbo_segment.set_size(4*this.V_segment.length),this.vbo_segment.set_data(0,this.V_segment)}}u.__name__="LineGLGlyph";var g=n(1231),p=n(1015);class v extends l{init(){const t=this.gl,e=(n=this._marker_code,"\nprecision mediump float;\nconst float SQRT_2 = 1.4142135623730951;\nconst float PI = 3.14159265358979323846264;\n//\nuniform float u_antialias;\n//\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvarying float v_linewidth;\nvarying float v_size;\nvarying vec2  v_rotation;\n\n".concat(n,"\n\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\n{\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\n    float select = float(bool(fg_color.a));\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\n    // Similarly, if we want a transparent bg\n    select = float(bool(bg_color.a));\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\n\n    if( border_distance < 0.0)\n        frag_color = fg_color;\n    else if( signed_distance < 0.0 ) {\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\n    } else {\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\n        } else {\n            discard;\n        }\n    }\n    return frag_color;\n}\n\nvoid main()\n{\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\n             v_rotation.y*P.x + v_rotation.x*P.y);\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\n    float distance = marker(P*point_size, v_size);\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\n    //gl_FragColor.rgb *= gl_FragColor.a;  // pre-multiply alpha\n}\n"));var n;this.prog=new i.Program(t),this.prog.set_shaders("\nprecision mediump float;\nconst float SQRT_2 = 1.4142135623730951;\n//\nuniform float u_pixel_ratio;\nuniform vec2 u_canvas_size;\nuniform vec2 u_offset;\nuniform vec2 u_scale;\nuniform float u_antialias;\n//\nattribute float a_x;\nattribute float a_y;\nattribute float a_size;\nattribute float a_angle;  // in radians\nattribute float a_linewidth;\nattribute vec4  a_fg_color;\nattribute vec4  a_bg_color;\n//\nvarying float v_linewidth;\nvarying float v_size;\nvarying vec4  v_fg_color;\nvarying vec4  v_bg_color;\nvarying vec2  v_rotation;\n\nvoid main (void)\n{\n    v_size = a_size * u_pixel_ratio;\n    v_linewidth = a_linewidth * u_pixel_ratio;\n    v_fg_color = a_fg_color;\n    v_bg_color = a_bg_color;\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\n    // Calculate position - the -0.5 is to correct for canvas origin\n    vec2 pos = (vec2(a_x, a_y) + u_offset) * u_scale; // in pixels\n    pos += 0.5;  // make up for Bokeh's offset\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\n    gl_Position.y *= -1.0;\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\n}\n",e),this.vbo_x=new i.VertexBuffer(t),this.prog.set_attribute("a_x","float",this.vbo_x),this.vbo_y=new i.VertexBuffer(t),this.prog.set_attribute("a_y","float",this.vbo_y),this.vbo_s=new i.VertexBuffer(t),this.prog.set_attribute("a_size","float",this.vbo_s),this.vbo_a=new i.VertexBuffer(t),this.prog.set_attribute("a_angle","float",this.vbo_a),this.vbo_linewidth=new i.VertexBuffer(t),this.vbo_fg_color=new i.VertexBuffer(t),this.vbo_bg_color=new i.VertexBuffer(t),this.index_buffer=new i.IndexBuffer(t)}draw(t,e,n){const a=e.glglyph,s=a.nvertices;if(a.data_changed){if(!isFinite(n.dx)||!isFinite(n.dy))return;a._baked_offset=[n.dx,n.dy],a._set_data(s),a.data_changed=!1}else this.glyph instanceof g.b&&null!=this.glyph._radius&&(null==this.last_trans||n.sx!=this.last_trans.sx||n.sy!=this.last_trans.sy)&&(this.last_trans=n,this.vbo_s.set_data(0,new Float32Array(Object(p.i)(this.glyph.sradius,t=>2*t))));this.visuals_changed&&(this._set_visuals(s),this.visuals_changed=!1);const i=a._baked_offset;if(this.prog.set_uniform("u_pixel_ratio","float",[n.pixel_ratio]),this.prog.set_uniform("u_canvas_size","vec2",[n.width,n.height]),this.prog.set_uniform("u_offset","vec2",[n.dx-i[0],n.dy-i[1]]),this.prog.set_uniform("u_scale","vec2",[n.sx,n.sy]),this.prog.set_attribute("a_x","float",a.vbo_x),this.prog.set_attribute("a_y","float",a.vbo_y),this.prog.set_attribute("a_size","float",a.vbo_s),this.prog.set_attribute("a_angle","float",a.vbo_a),0!=t.length)if(t.length===s)this.prog.draw(this.gl.POINTS,[0,s]);else if(s<65535){const e=window.navigator.userAgent;e.indexOf("MSIE ")+e.indexOf("Trident/")+e.indexOf("Edge/")>0&&r.a.warn("WebGL warning: IE is known to produce 1px sprites whith selections."),this.index_buffer.set_size(2*t.length),this.index_buffer.set_data(0,new Uint16Array(t)),this.prog.draw(this.gl.POINTS,this.index_buffer)}else{const e=64e3,n=[];for(let t=0,a=Math.ceil(s/e);t<a;t++)n.push([]);for(let a=0,s=t.length;a<s;a++){const s=t[a]%e;n[Math.floor(t[a]/e)].push(s)}for(let t=0,s=n.length;t<s;t++){const s=new Uint16Array(n[t]),i=t*e*4;0!==s.length&&(this.prog.set_attribute("a_x","float",a.vbo_x,0,i),this.prog.set_attribute("a_y","float",a.vbo_y,0,i),this.prog.set_attribute("a_size","float",a.vbo_s,0,i),this.prog.set_attribute("a_angle","float",a.vbo_a,0,i),this.vbo_linewidth.used&&this.prog.set_attribute("a_linewidth","float",this.vbo_linewidth,0,i),this.vbo_fg_color.used&&this.prog.set_attribute("a_fg_color","vec4",this.vbo_fg_color,0,4*i),this.vbo_bg_color.used&&this.prog.set_attribute("a_bg_color","vec4",this.vbo_bg_color,0,4*i),this.index_buffer.set_size(2*s.length),this.index_buffer.set_data(0,s),this.prog.draw(this.gl.POINTS,this.index_buffer))}}}_set_data(t){const e=4*t;this.vbo_x.set_size(e),this.vbo_y.set_size(e),this.vbo_a.set_size(e),this.vbo_s.set_size(e);const n=new Float64Array(this.glyph._x),a=new Float64Array(this.glyph._y);for(let s=0,i=t;s<i;s++)n[s]+=this._baked_offset[0],a[s]+=this._baked_offset[1];this.vbo_x.set_data(0,new Float32Array(n)),this.vbo_y.set_data(0,new Float32Array(a)),null!=this.glyph._angle&&this.vbo_a.set_data(0,new Float32Array(this.glyph._angle)),this.glyph instanceof g.b&&null!=this.glyph._radius?this.vbo_s.set_data(0,new Float32Array(Object(p.i)(this.glyph.sradius,t=>2*t))):this.vbo_s.set_data(0,new Float32Array(this.glyph._size))}_set_visuals(t){!function(t,e,n,a,s,i){if(s.doit)if(_(s,i))e.used=!1,t.set_attribute(n,"float",s[i].value());else{e.used=!0;const o=new Float32Array(s.cache[i+"_array"]);e.set_size(4*a),e.set_data(0,o),t.set_attribute(n,"float",e)}else e.used=!1,t.set_attribute(n,"float",[0])}(this.prog,this.vbo_linewidth,"a_linewidth",t,this.glyph.visuals.line,"line_width"),h(this.prog,this.vbo_fg_color,"a_fg_color",t,this.glyph.visuals.line,"line"),h(this.prog,this.vbo_bg_color,"a_bg_color",t,this.glyph.visuals.fill,"fill"),this.prog.set_uniform("u_antialias","float",[.8])}}function m(t){return class extends v{get _marker_code(){return t}}}v.__name__="MarkerGLGlyph";const x=m("\nfloat marker(vec2 P, float size)\n{\n    return length(P) - size/2.0;\n}\n"),y=m("\nfloat marker(vec2 P, float size)\n{\n    return max(abs(P.x), abs(P.y)) - size/2.0;\n}\n"),b=m("\nfloat marker(vec2 P, float size)\n{\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\n    return r1 / SQRT_2;\n}\n"),w=m("\nfloat marker(vec2 P, float size)\n{\n    P.y -= size * 0.3;\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\n    float r2 = P.y;\n    return max(r1 / SQRT_2, r2);  // Intersect diamond with rectangle\n}\n"),P=m("\nfloat marker(vec2 P, float size)\n{\n    P.y += size * 0.3;\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\n    float r2 = - P.y;\n    return max(r1 / SQRT_2, r2);  // Intersect diamond with rectangle\n}\n"),A=m("\nfloat marker(vec2 P, float size)\n{\n    vec2 q = abs(P);\n    return max(q.y * 0.57735 + q.x - 1.0 * size/2.0, q.y - 0.866 * size/2.0);\n}\n"),z=m('\nfloat marker(vec2 P, float size)\n{\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;   // 2.5 is a tweak\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of "width" for aa\n    return max(square, cross);\n}\n'),q=m("\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float circle = length(P) - size/2.0;\n    float c1 = max(circle, s1);\n    float c2 = max(circle, s2);\n    float c3 = max(circle, s3);\n    float c4 = max(circle, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n"),T=m("\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\n    float c1 = max(square, s1);\n    float c2 = max(square, s2);\n    float c3 = max(square, s3);\n    float c4 = max(square, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n"),E=m("\nfloat marker(vec2 P, float size)\n{\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\n    diamond /= SQRT_2;\n    float c1 = max(diamond, s1);\n    float c2 = max(diamond, s2);\n    float c3 = max(diamond, s3);\n    float c4 = max(diamond, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n"),k=m('\nfloat marker(vec2 P, float size)\n{\n    float circle = length(P) - size / 1.6;\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of "width" for aa\n    return max(circle, X);\n}\n'),S=m('\nfloat marker(vec2 P, float size)\n{\n    float x = P.x - P.y;\n    float y = P.x + P.y;\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float circle = length(P) - size/2.0;\n    float c1 = max(circle, s1);\n    float c2 = max(circle, s2);\n    float c3 = max(circle, s3);\n    float c4 = max(circle, s4);\n    // Union\n    float almost = min(min(min(c1, c2), c3), c4);\n    // In this case, the X is also outside of the main shape\n    float Xmask = length(P) - size / 1.6;  // a circle\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of "width" for aa\n    return min(max(X, Xmask), almost);\n}\n'),R=m("\nfloat marker(vec2 P, float size)\n{\n    float x = P.x - P.y;\n    float y = P.x + P.y;\n    // Define quadrants\n    float qs = size / 2.0;  // quadrant size\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\n    // Intersect main shape with quadrants (to form cross)\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\n    float c1 = max(square, s1);\n    float c2 = max(square, s2);\n    float c3 = max(square, s3);\n    float c4 = max(square, s4);\n    // Union\n    return min(min(min(c1, c2), c3), c4);\n}\n"),I=m('\nfloat marker(vec2 P, float size)\n{\n    // Masks\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\n    // Shapes\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of "width" for aa\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of "width" for aa\n    // Result is union of masked shapes\n    return min(max(X, diamond), max(cross, square));\n}\n');n.d(e,"LineGLGlyph",(function(){return u})),n.d(e,"MarkerGLGlyph",(function(){return v})),n.d(e,"CircleGLGlyph",(function(){return x})),n.d(e,"SquareGLGlyph",(function(){return y})),n.d(e,"DiamondGLGlyph",(function(){return b})),n.d(e,"TriangleGLGlyph",(function(){return w})),n.d(e,"InvertedTriangleGLGlyph",(function(){return P})),n.d(e,"HexGLGlyph",(function(){return A})),n.d(e,"CrossGLGlyph",(function(){return z})),n.d(e,"CircleCrossGLGlyph",(function(){return q})),n.d(e,"SquareCrossGLGlyph",(function(){return T})),n.d(e,"DiamondCrossGLGlyph",(function(){return E})),n.d(e,"XGLGlyph",(function(){return k})),n.d(e,"CircleXGLGlyph",(function(){return S})),n.d(e,"SquareXGLGlyph",(function(){return R})),n.d(e,"AsteriskGLGlyph",(function(){return I}))}}]);
//# sourceMappingURL=35.7ecd7817.chunk.js.map